//@version=6
indicator("ICT Multi-Module Indicator [v6: Optimized]", overlay=true,
         max_boxes_count=100,
         max_lines_count=100)

// ========== GLOBAL TOGGLES ==========
i_show_ob   = input.bool(true, "Show Order Blocks", group="Global")
i_show_fvg  = input.bool(true, "Show FVG", group="Global")
i_show_bos  = input.bool(true, "Show BOS", group="Global")
i_show_liq  = input.bool(true, "Show Liquidity", group="Global")
i_show_po3  = input.bool(true, "Show Po3", group="Global")
i_show_conf = input.bool(true, "Show Confluence", group="Global")

// Alerts
i_alert_ob   = input.bool(true, "Alert: OB touch", group="Alerts")
i_alert_fvg  = input.bool(true, "Alert: FVG first test", group="Alerts")
i_alert_liq  = input.bool(true, "Alert: Liquidity sweep", group="Alerts")
i_alert_conf = input.bool(true, "Alert: Confluence >= threshold", group="Alerts")

// Visual limits
i_max_ob   = input.int(3, "Max OB", 1, 10, group="Visual limits")
i_max_fvg  = input.int(2, "Max FVG", 1, 10, group="Visual limits")
i_max_liq  = input.int(3, "Max Liquidity", 1, 10, group="Visual limits")

// ========== LIFECYCLE / RESET ==========
var string prev_tf     = timeframe.period
var string prev_ticker = ticker.standard(syminfo.tickerid)
var bool needs_reset   = false

if timeframe.period != prev_tf or ticker.standard(syminfo.tickerid) != prev_ticker
    prev_tf     := timeframe.period
    prev_ticker := ticker.standard(syminfo.tickerid)
    needs_reset := true

// Simplified object tracking
f_track_box(box b) => b
f_track_line(line l) => l
f_track_label(label lb) => lb

// ========== COMMONS ==========
atr = ta.atr(14)
var string current_trend = "neutral"

// Po3 globals (must be declared early for use in confluence)
type Po3Phase
    string phase
    float acc_high
    float acc_low
    float manip_level
    float expansion_target
    int start_bar
    line target_line
    label label_id

var Po3Phase PO3 = Po3Phase.new("accumulation", na, na, na, na, na, na, na)
var bool po3_active = false

// ========== HTF BIAS ==========
i_mtf_enabled = input.bool(true, "Enable HTF bias", group="HTF")
i_htf_1 = input.timeframe("60", "HTF-1", group="HTF")
i_htf_2 = input.timeframe("240", "HTF-2", group="HTF")
htf_close_1 = i_mtf_enabled ? request.security(syminfo.tickerid, i_htf_1, close) : na
htf_close_2 = i_mtf_enabled ? request.security(syminfo.tickerid, i_htf_2, close) : na
htf_ma_1    = i_mtf_enabled ? request.security(syminfo.tickerid, i_htf_1, ta.sma(close, 50)) : na
htf_ma_2    = i_mtf_enabled ? request.security(syminfo.tickerid, i_htf_2, ta.sma(close, 50)) : na
htf_bias_bull = i_mtf_enabled ? (htf_close_1 > htf_ma_1 and htf_close_2 > htf_ma_2) : true
htf_bias_bear = i_mtf_enabled ? (htf_close_1 < htf_ma_1 and htf_close_2 < htf_ma_2) : true

// ========== BOS ==========
i_bos_lookback = input.int(10, "Swing lookback", 5, group="BOS")
i_bos_min_atr = input.float(1.5, "Min move (x ATR)", 0.5, group="BOS", tooltip="ATR-baserad BOS threshold. 1.5 är standard, 1.0-2.5 för olika timeframes")
i_bos_vol_filter = input.bool(true, "Volume filter", group="BOS")
i_bos_vol_thr = input.float(1.2, "Vol threshold (x MA)", 1.0, group="BOS")
i_bos_ext = input.int(20, "Line extension (bars)", 1, group="BOS")

type BOSLine
    float level
    bool bull
    int start_idx
    line line_id
    label label_id

var array<BOSLine> BOSs = array.new<BOSLine>()

f_swing_high(int lb) =>
    hh = high[lb], ok = true
    for i = 0 to lb - 1
        if high[i] > hh
            ok := false
            break
    for i = lb + 1 to lb * 2
        if high[i] > hh
            ok := false
            break
    ok ? hh : na

f_swing_low(int lb) =>
    ll = low[lb], ok = true
    for i = 0 to lb - 1
        if low[i] < ll
            ok := false
            break
    for i = lb + 1 to lb * 2
        if low[i] < ll
            ok := false
            break
    ok ? ll : na

if i_show_bos
    sh = f_swing_high(i_bos_lookback)
    sl = f_swing_low(i_bos_lookback)
    vma = ta.sma(volume, 20)

    if not na(sh) and close > sh and barstate.isconfirmed
        move_size = close - sh
        vok = not i_bos_vol_filter or volume > vma * i_bos_vol_thr
        if move_size >= atr * i_bos_min_atr and vok
            ln = line.new(bar_index - i_bos_lookback, sh, bar_index + i_bos_ext, sh, xloc=xloc.bar_index, color=color.green, width=2)
            lb = label.new(bar_index, sh + atr * 0.2, "BOS↑", xloc=xloc.bar_index, color=color.green, textcolor=color.white, style=label.style_label_up, size=size.tiny)
            array.push(BOSs, BOSLine.new(sh, true, bar_index - i_bos_lookback, ln, lb))
            f_track_line(ln)
            f_track_label(lb)
            current_trend := "bullish"

    if not na(sl) and close < sl and barstate.isconfirmed
        move_size = sl - close
        vok = not i_bos_vol_filter or volume > vma * i_bos_vol_thr
        if move_size >= atr * i_bos_min_atr and vok
            ln = line.new(bar_index - i_bos_lookback, sl, bar_index + i_bos_ext, sl, xloc=xloc.bar_index, color=color.red, width=2)
            lb = label.new(bar_index, sl - atr * 0.2, "BOS↓", xloc=xloc.bar_index, color=color.red, textcolor=color.white, style=label.style_label_down, size=size.tiny)
            array.push(BOSs, BOSLine.new(sl, false, bar_index - i_bos_lookback, ln, lb))
            f_track_line(ln)
            f_track_label(lb)
            current_trend := "bearish"

    if array.size(BOSs) > 0
        for i = 0 to array.size(BOSs) - 1
            b = array.get(BOSs, i)
            line.set_x2(b.line_id, bar_index + i_bos_ext)
            label.set_x(b.label_id, bar_index)

// ========== ORDER BLOCKS ==========
i_ob_wick_thr = input.float(0.3, "OB wick threshold", 0.0, 1.0, group="OB")
i_ob_ext = input.int(30, "OB extension (bars)", 1, group="OB")
i_ob_max_retests = input.int(3, "OB max retests", 0, 10, group="OB")
i_ob_inval_close_beyond = input.bool(true, "Invalidate on close beyond", group="OB")

type OrderBlock
    float top
    float bottom
    int strength
    bool bull
    int start_idx
    bool active
    int retests
    box box_id
    line mid_line

var array<OrderBlock> OBs = array.new<OrderBlock>()

f_ob_strength(float body, float wick_ratio, float vol_ratio) =>
    s = 0
    if body > atr * 0.5
        s += 1
    if wick_ratio < i_ob_wick_thr
        s += 1
    if vol_ratio > 1.2
        s += 1
    s

f_detect_bull_ob() =>
    ok = false, top = 0.0, bot = 0.0, strn = 0
    vma = ta.sma(volume, 20)
    if close > open and close > open[1] and open < close[1] and close[1] < open[1]
        body = open[1] - close[1]
        lw = close[1] - low[1]
        wr = body > 0 ? lw / body : 0
        vr = vma > 0 ? volume[1] / vma : 1
        if wr <= i_ob_wick_thr
            ok := true, top := open[1], bot := close[1], strn := f_ob_strength(body, wr, vr)
    [ok, top, bot, strn]

f_detect_bear_ob() =>
    ok = false, top = 0.0, bot = 0.0, strn = 0
    vma = ta.sma(volume, 20)
    if close < open and close < open[1] and open > close[1] and close[1] > open[1]
        body = close[1] - open[1]
        uw = high[1] - close[1]
        wr = body > 0 ? uw / body : 0
        vr = vma > 0 ? volume[1] / vma : 1
        if wr <= i_ob_wick_thr
            ok := true, top := close[1], bot := open[1], strn := f_ob_strength(body, wr, vr)
    [ok, top, bot, strn]

if i_show_ob
    [b_ok, b_top, b_bot, b_str] = f_detect_bull_ob()
    if b_ok and barstate.isconfirmed
        if array.size(OBs) >= i_max_ob
            old = array.shift(OBs)
            box.delete(old.box_id)
            line.delete(old.mid_line)
        clr = b_str == 3 ? color.new(color.yellow, 80) : b_str == 2 ? color.new(color.yellow, 85) : color.new(color.yellow, 90)
        bx = box.new(bar_index - 1, b_top, bar_index + i_ob_ext, b_bot, xloc=xloc.bar_index, border_color=color.yellow, bgcolor=clr)
        mid = (b_top + b_bot) * 0.5
        mid_ln = line.new(bar_index - 1, mid, bar_index + i_ob_ext, mid, xloc=xloc.bar_index, color=color.new(color.yellow, 50), width=1, style=line.style_dashed)
        f_track_box(bx)
        f_track_line(mid_ln)
        array.push(OBs, OrderBlock.new(b_top, b_bot, b_str, true, bar_index - 1, false, 0, bx, mid_ln))

    [s_ok, s_top, s_bot, s_str] = f_detect_bear_ob()
    if s_ok and barstate.isconfirmed
        if array.size(OBs) >= i_max_ob
            old = array.shift(OBs)
            box.delete(old.box_id)
            line.delete(old.mid_line)
        clr = s_str == 3 ? color.new(color.orange, 80) : s_str == 2 ? color.new(color.orange, 85) : color.new(color.orange, 90)
        bx = box.new(bar_index - 1, s_top, bar_index + i_ob_ext, s_bot, xloc=xloc.bar_index, border_color=color.orange, bgcolor=clr)
        mid = (s_top + s_bot) * 0.5
        mid_ln = line.new(bar_index - 1, mid, bar_index + i_ob_ext, mid, xloc=xloc.bar_index, color=color.new(color.orange, 50), width=1, style=line.style_dashed)
        f_track_box(bx)
        f_track_line(mid_ln)
        array.push(OBs, OrderBlock.new(s_top, s_bot, s_str, false, bar_index - 1, false, 0, bx, mid_ln))

if array.size(OBs) > 0
    for i = array.size(OBs) - 1 to 0
        ob = array.get(OBs, i)
        box.set_right(ob.box_id, bar_index + i_ob_ext)
        line.set_x2(ob.mid_line, bar_index + i_ob_ext)
        if not ob.active
            ob.active := ob.bull ? current_trend == "bullish" : current_trend == "bearish"
            array.set(OBs, i, ob)
        touching = low <= ob.top and high >= ob.bottom
        if touching
            ob.retests += 1
            array.set(OBs, i, ob)
            if i_alert_ob
                alert("OB touch: " + (ob.bull ? "Bullish" : "Bearish") + " zone", alert.freq_once_per_bar)
        broken = ob.bull ? (i_ob_inval_close_beyond ? close < ob.bottom : low < ob.bottom)
                         : (i_ob_inval_close_beyond ? close > ob.top    : high > ob.top)
        too_many = (i_ob_max_retests > 0 and ob.retests > i_ob_max_retests)
        if broken or too_many
            box.delete(ob.box_id)
            line.delete(ob.mid_line)
            array.remove(OBs, i)

// ========== FVG ==========
i_fvg_min_atr = input.float(0.0, "FVG min size (%ATR)", 0.0, group="FVG")
i_fvg_ext     = input.int(30, "FVG extension (bars)", 1, group="FVG")
i_fvg_inval   = input.string("full_fill", "FVG invalidation", options=["full_fill","close_inside","midpoint"], group="FVG")

type FairValueGap
    float top
    float bottom
    bool bull
    int start_idx
    bool tested
    box box_id
    line mid_line

var array<FairValueGap> FVGs = array.new<FairValueGap>()

f_detect_bull_fvg() =>
    ok = false, top = 0.0, bot = 0.0
    if low > high[2]
        gap = low - high[2]
        if gap >= atr * i_fvg_min_atr
            ok := true, top := low, bot := high[2]
    [ok, top, bot]

f_detect_bear_fvg() =>
    ok = false, top = 0.0, bot = 0.0
    if high < low[2]
        gap = low[2] - high
        if gap >= atr * i_fvg_min_atr
            ok := true, top := low[2], bot := high
    [ok, top, bot]

if i_show_fvg
    [fb, ftop, fbot] = f_detect_bull_fvg()
    if fb and barstate.isconfirmed
        if array.size(FVGs) >= i_max_fvg
            old = array.shift(FVGs)
            box.delete(old.box_id)
            line.delete(old.mid_line)
        c = color.new(color.green, 85)
        bx = box.new(bar_index - 2, ftop, bar_index + i_fvg_ext, fbot, xloc=xloc.bar_index, border_color=color.green, bgcolor=c, border_style=line.style_dashed)
        mid = (ftop + fbot) * 0.5
        mid_ln = line.new(bar_index - 2, mid, bar_index + i_fvg_ext, mid, xloc=xloc.bar_index, color=color.new(color.green, 50), width=1, style=line.style_dashed)
        f_track_box(bx)
        f_track_line(mid_ln)
        array.push(FVGs, FairValueGap.new(ftop, fbot, true, bar_index - 2, false, bx, mid_ln))

    [sb, stop, sbot] = f_detect_bear_fvg()
    if sb and barstate.isconfirmed
        if array.size(FVGs) >= i_max_fvg
            old = array.shift(FVGs)
            box.delete(old.box_id)
            line.delete(old.mid_line)
        c = color.new(color.red, 85)
        bx = box.new(bar_index - 2, stop, bar_index + i_fvg_ext, sbot, xloc=xloc.bar_index, border_color=color.red, bgcolor=c, border_style=line.style_dashed)
        mid = (stop + sbot) * 0.5
        mid_ln = line.new(bar_index - 2, mid, bar_index + i_fvg_ext, mid, xloc=xloc.bar_index, color=color.new(color.red, 50), width=1, style=line.style_dashed)
        f_track_box(bx)
        f_track_line(mid_ln)
        array.push(FVGs, FairValueGap.new(stop, sbot, false, bar_index - 2, false, bx, mid_ln))

if array.size(FVGs) > 0
    for i = array.size(FVGs) - 1 to 0
        fvg = array.get(FVGs, i)
        box.set_right(fvg.box_id, bar_index + i_fvg_ext)
        line.set_x2(fvg.mid_line, bar_index + i_fvg_ext)
        tested_now = fvg.bull ? (low <= fvg.top and high >= fvg.bottom)
                              : (high >= fvg.bottom and low <= fvg.top)
        if tested_now and not fvg.tested
            fvg.tested := true
            array.set(FVGs, i, fvg)
            if i_alert_fvg
                alert("FVG first test: " + (fvg.bull ? "Bullish" : "Bearish"), alert.freq_once_per_bar)
        mid = (fvg.top + fvg.bottom) * 0.5
        full_fill   = fvg.bull ? close <= fvg.bottom : close >= fvg.top
        close_inside= close >= fvg.bottom and close <= fvg.top
        hit_mid     = fvg.bull ? low <= mid : high >= mid
        inval = i_fvg_inval == "full_fill" ? full_fill : i_fvg_inval == "close_inside" ? close_inside : hit_mid
        if inval
            box.delete(fvg.box_id)
            line.delete(fvg.mid_line)
            array.remove(FVGs, i)

// ========== LIQUIDITY ==========
i_liq_lookback = input.int(20, "Liquidity lookback", 5, group="LIQ")
i_liq_min_swing = input.float(0.3, "Min swing (%ATR)", 0.1, group="LIQ")
i_liq_ext = input.int(25, "Line extension (bars)", 1, group="LIQ")

type LiquidityPool
    float level
    bool is_high
    int start_idx
    line line_id
    label label_id

var array<LiquidityPool> LIQs = array.new<LiquidityPool>()

liq_lowest  = ta.lowest(low,  i_liq_lookback * 2)
liq_highest = ta.highest(high, i_liq_lookback * 2)

f_liq_high() =>
    ph = ta.pivothigh(high, i_liq_lookback, i_liq_lookback)
    ok = false
    if not na(ph)
        sz = ph - liq_lowest
        if sz >= atr * i_liq_min_swing
            ok := true
    [ok, ph]

f_liq_low() =>
    pl = ta.pivotlow(low, i_liq_lookback, i_liq_lookback)
    ok = false
    if not na(pl)
        sz = liq_highest - pl
        if sz >= atr * i_liq_min_swing
            ok := true
    [ok, pl]

if i_show_liq
    [okh, lh] = f_liq_high()
    if okh and barstate.isconfirmed
        if array.size(LIQs) >= i_max_liq
            old = array.shift(LIQs)
            line.delete(old.line_id)
            if not na(old.label_id)
                label.delete(old.label_id)
        ln = line.new(bar_index - i_liq_lookback, lh, bar_index + i_liq_ext, lh, xloc=xloc.bar_index, color=color.aqua, width=1, style=line.style_dotted)
        lb = label.new(bar_index - i_liq_lookback, lh + atr * 0.1, "LIQ", xloc=xloc.bar_index, color=color.aqua, textcolor=color.white, style=label.style_label_down, size=size.tiny)
        f_track_line(ln)
        f_track_label(lb)
        array.push(LIQs, LiquidityPool.new(lh, true, bar_index - i_liq_lookback, ln, lb))
    [okl, ll] = f_liq_low()
    if okl and barstate.isconfirmed
        if array.size(LIQs) >= i_max_liq
            old = array.shift(LIQs)
            line.delete(old.line_id)
            if not na(old.label_id)
                label.delete(old.label_id)
        ln = line.new(bar_index - i_liq_lookback, ll, bar_index + i_liq_ext, ll, xloc=xloc.bar_index, color=color.aqua, width=1, style=line.style_dotted)
        lb = label.new(bar_index - i_liq_lookback, ll - atr * 0.1, "LIQ", xloc=xloc.bar_index, color=color.aqua, textcolor=color.white, style=label.style_label_up, size=size.tiny)
        f_track_line(ln)
        f_track_label(lb)
        array.push(LIQs, LiquidityPool.new(ll, false, bar_index - i_liq_lookback, ln, lb))

if array.size(LIQs) > 0
    for i = array.size(LIQs) - 1 to 0
        liq = array.get(LIQs, i)
        line.set_x2(liq.line_id, bar_index + i_liq_ext)
        swept = liq.is_high ? high > liq.level : low < liq.level
        if swept
            if i_alert_liq
                alert("Liquidity swept: " + (liq.is_high ? "High " : "Low ") + str.tostring(liq.level), alert.freq_once_per_bar)
            line.delete(liq.line_id)
            if not na(liq.label_id)
                label.delete(liq.label_id)
            array.remove(LIQs, i)

// ========== Po3 ==========
i_po3_enabled = input.bool(true, "Enable Po3", group="Po3")
i_po3_depth   = input.int(5, "Fractal depth", 3, group="Po3")
i_po3_mult    = input.float(1.5, "Expansion multiplier", 1.0, group="Po3")
i_po3_ext     = input.int(30, "Target extension (bars)", 1, group="Po3")
i_po3_man_thr = input.float(0.3, "Manip threshold (%ATR)", 0.1, group="Po3")

f_po3_acc() =>
    rh = ta.highest(high, i_po3_depth * 2)
    rl = ta.lowest(low, i_po3_depth * 2)
    sz = rh - rl
    is_acc = sz < atr * 0.5
    [is_acc, rh, rl]

f_po3_manip(float acc_h, float acc_l) =>
    is_man = false, level = 0.0, bull = false
    if low < acc_l - atr * i_po3_man_thr
        is_man := true
        level := low
        bull := true
    if high > acc_h + atr * i_po3_man_thr
        is_man := true
        level := high
        bull := false
    [is_man, level, bull]

if i_show_po3 and i_po3_enabled
    [is_acc, acc_h, acc_l] = f_po3_acc()
    if is_acc and PO3.phase == "accumulation"
        PO3.acc_high := acc_h
        PO3.acc_low  := acc_l
        PO3.start_bar:= bar_index

    [is_man, m_level, bull_man] = f_po3_manip(PO3.acc_high, PO3.acc_low)
    if is_man and PO3.phase == "accumulation" and barstate.isconfirmed
        PO3.phase := "manipulation"
        PO3.manip_level := m_level
        acc_range = PO3.acc_high - PO3.acc_low

        var label lb = na
        if bull_man
            PO3.expansion_target := PO3.acc_high + acc_range * i_po3_mult
            lb := label.new(bar_index, low - atr * 0.3, "Po3 MANIP↓→↑", xloc=xloc.bar_index, color=color.blue, textcolor=color.white, style=label.style_label_up, size=size.tiny)
        else
            PO3.expansion_target := PO3.acc_low - acc_range * i_po3_mult
            lb := label.new(bar_index, high + atr * 0.3, "Po3 MANIP↑→↓", xloc=xloc.bar_index, color=color.blue, textcolor=color.white, style=label.style_label_down, size=size.tiny)

        ln = line.new(bar_index, PO3.expansion_target, bar_index + i_po3_ext, PO3.expansion_target, xloc=xloc.bar_index, color=color.blue, width=2, style=line.style_dashed)
        PO3.target_line := ln
        PO3.label_id    := lb
        f_track_line(ln)
        f_track_label(lb)
        po3_active := true

    if po3_active and PO3.phase == "manipulation" and not na(PO3.target_line)
        line.set_x2(PO3.target_line, bar_index + i_po3_ext)
        if not na(PO3.label_id)
            label.set_x(PO3.label_id, bar_index)

// ========== HTF FVG (overlay) ==========
i_htf_fvg_enabled = input.bool(false, "Enable HTF FVG overlay", group="HTF FVG")
i_htf_fvg_tf = input.timeframe("240", "HTF FVG timeframe", group="HTF FVG")
i_htf_fvg_min_atr = input.float(0.3, "HTF FVG min size (%ATR HTF)", 0.0, group="HTF FVG")
i_htf_fvg_ext = input.int(60, "HTF FVG extension (bars)", 1, group="HTF FVG")

htf_low   = i_htf_fvg_enabled ? request.security(syminfo.tickerid, i_htf_fvg_tf, low)  : na
htf_high  = i_htf_fvg_enabled ? request.security(syminfo.tickerid, i_htf_fvg_tf, high) : na
htf_atr   = i_htf_fvg_enabled ? request.security(syminfo.tickerid, i_htf_fvg_tf, ta.atr(14)) : na

var box htf_fvg_box_last = na
var line htf_fvg_mid_line = na
var bool htf_fvg_is_bull = false

htf_fvg_bull = i_htf_fvg_enabled and not na(htf_low) and not na(htf_high[2]) and (htf_low > htf_high[2]) and (htf_low - htf_high[2] >= htf_atr * i_htf_fvg_min_atr)
htf_fvg_bear = i_htf_fvg_enabled and not na(htf_high) and not na(htf_low[2])  and (htf_high < htf_low[2]) and (htf_low[2] - htf_high >= htf_atr * i_htf_fvg_min_atr)

if i_htf_fvg_enabled and barstate.isconfirmed
    if htf_fvg_bull
        if not na(htf_fvg_box_last)
            box.delete(htf_fvg_box_last)
        if not na(htf_fvg_mid_line)
            line.delete(htf_fvg_mid_line)
        c = color.new(color.green, 90)
        htf_fvg_box_last := box.new(bar_index - 2, htf_low, bar_index + i_htf_fvg_ext, htf_high[2], xloc=xloc.bar_index, border_color=color.new(color.green, 0), bgcolor=c)
        f_track_box(htf_fvg_box_last)
        htf_fvg_is_bull := true
        // 50% midline
        mid_level = (htf_low + htf_high[2]) / 2
        htf_fvg_mid_line := line.new(bar_index - 2, mid_level, bar_index + i_htf_fvg_ext, mid_level, xloc=xloc.bar_index, color=color.new(color.green, 0), width=1, style=line.style_dashed)
        f_track_line(htf_fvg_mid_line)
    if htf_fvg_bear
        if not na(htf_fvg_box_last)
            box.delete(htf_fvg_box_last)
        if not na(htf_fvg_mid_line)
            line.delete(htf_fvg_mid_line)
        c = color.new(color.red, 90)
        htf_fvg_box_last := box.new(bar_index - 2, htf_low[2], bar_index + i_htf_fvg_ext, htf_high, xloc=xloc.bar_index, border_color=color.new(color.red, 0), bgcolor=c)
        f_track_box(htf_fvg_box_last)
        htf_fvg_is_bull := false
        // 50% midline
        mid_level = (htf_low[2] + htf_high) / 2
        htf_fvg_mid_line := line.new(bar_index - 2, mid_level, bar_index + i_htf_fvg_ext, mid_level, xloc=xloc.bar_index, color=color.new(color.red, 0), width=1, style=line.style_dashed)
        f_track_line(htf_fvg_mid_line)

if not na(htf_fvg_box_last)
    box.set_right(htf_fvg_box_last, bar_index + i_htf_fvg_ext)
if not na(htf_fvg_mid_line)
    line.set_x2(htf_fvg_mid_line, bar_index + i_htf_fvg_ext)

// ========== Confluence ==========
i_conf_thr  = input.int(70, "Confluence threshold", 0, 100, group="Confluence")
i_w_ob      = input.float(25.0, "Weight OB", 0, 100, group="Confluence")
i_w_fvg     = input.float(20.0, "Weight FVG", 0, 100, group="Confluence")
i_w_bos     = input.float(15.0, "Weight BOS", 0, 100, group="Confluence")
i_w_liq     = input.float(30.0, "Weight LIQ", 0, 100, group="Confluence")
i_w_po3     = input.float(10.0, "Weight Po3", 0, 100, group="Confluence")
i_w_htf     = input.float(0.0, "Weight HTF bias", 0, 100, group="Confluence")

f_confluence() =>
    ob_b = 0.0, ob_s = 0.0
    if array.size(OBs) > 0
        for i = 0 to array.size(OBs) - 1
            ob = array.get(OBs, i)
            if ob.active and close >= ob.bottom and close <= ob.top
                mul = ob.strength / 3.0
                if ob.bull
                    ob_b := math.max(ob_b, mul)
                else
                    ob_s := math.max(ob_s, mul)

    fvg_b = 0.0, fvg_s = 0.0
    if array.size(FVGs) > 0
        for i = 0 to array.size(FVGs) - 1
            fvg = array.get(FVGs, i)
            if close >= fvg.bottom and close <= fvg.top
                if fvg.bull
                    fvg_b := 1.0
                else
                    fvg_s := 1.0

    bos_b = current_trend == "bullish" ? 1.0 : 0.0
    bos_s = current_trend == "bearish" ? 1.0 : 0.0

    liq_b = 0.0, liq_s = 0.0
    if array.size(LIQs) > 0
        for i = 0 to array.size(LIQs) - 1
            liq = array.get(LIQs, i)
            dist = math.abs(close - liq.level)
            if dist < atr * 0.5
                if liq.is_high
                    liq_s := 1.0
                else
                    liq_b := 1.0

    po3_b = 0.0, po3_s = 0.0
    if po3_active and not na(PO3.expansion_target)
        sig = PO3.expansion_target > close ? 1.0 : -1.0
        if sig > 0
            po3_b := 1.0
        else
            po3_s := 1.0

    htf_b = i_mtf_enabled and htf_bias_bull ? 1.0 : 0.0
    htf_s = i_mtf_enabled and htf_bias_bear ? 1.0 : 0.0

    wsum = i_w_ob + i_w_fvg + i_w_bos + i_w_liq + i_w_po3 + i_w_htf
    bull = (ob_b * i_w_ob + fvg_b * i_w_fvg + bos_b * i_w_bos + liq_b * i_w_liq + po3_b * i_w_po3 + htf_b * i_w_htf) / (wsum == 0 ? 1 : wsum)
    bear = (ob_s * i_w_ob + fvg_s * i_w_fvg + bos_s * i_w_bos + liq_s * i_w_liq + po3_s * i_w_po3 + htf_s * i_w_htf) / (wsum == 0 ? 1 : wsum)
    net = bull - bear
    conf = math.round(math.max(bull, bear) * 100)
    dir = net > 0 ? "long" : net < 0 ? "short" : "neutral"
    [conf, dir]

var int hold = 0
var string prev_conf_dir = "neutral"
[conf_score, conf_dir] = f_confluence()
stable_dir = conf_dir

// Reversal kräver 3 bars bekräftelse, continuation bara 2
reversal_detected = (prev_conf_dir == "long" and conf_dir == "short") or (prev_conf_dir == "short" and conf_dir == "long")
required_hold = reversal_detected ? 3 : 2

if conf_score >= i_conf_thr
    if conf_dir == prev_conf_dir or prev_conf_dir == "neutral"
        hold += 1
    else
        hold := 1  // Reset vid riktningsändring
    
    if hold < required_hold
        stable_dir := "neutral"
else
    hold := 0

prev_conf_dir := conf_dir

var label conf_label = na
if i_show_conf
    if not na(conf_label)
        label.delete(conf_label)
    if conf_score >= i_conf_thr
        lc = stable_dir == "long" ? color.green : stable_dir == "short" ? color.red : color.gray
        txt = stable_dir + " " + str.tostring(conf_score, "#") + "%"
        conf_label := label.new(bar_index, high + atr * 0.5, txt, xloc=xloc.bar_index, color=lc, textcolor=color.white, style=label.style_label_down, size=size.normal)
        f_track_label(conf_label)
        if i_alert_conf and (stable_dir == "long" or stable_dir == "short")
            alert("Confluence: " + stable_dir + " " + str.tostring(conf_score, "#") + "%", alert.freq_once_per_bar)

// ========== INFO DASHBOARD ==========
i_show_dashboard = input.bool(true, "Show Info Dashboard", group="Dashboard")

if i_show_dashboard and barstate.islast
    var table dashboard = table.new(position.top_right, 2, 8, border_width=1)
    
    // Header
    table.cell(dashboard, 0, 0, "ICT Sentiment", text_color=color.white, bgcolor=color.new(color.gray, 20), text_size=size.normal)
    table.cell(dashboard, 1, 0, "", text_color=color.white, bgcolor=color.new(color.gray, 20))
    
    // HTF Bias
    htf_status = htf_bias_bull ? "BULLISH" : htf_bias_bear ? "BEARISH" : "NEUTRAL"
    htf_color = htf_bias_bull ? color.new(color.green, 70) : htf_bias_bear ? color.new(color.red, 70) : color.new(color.gray, 70)
    table.cell(dashboard, 0, 1, "HTF Bias", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(dashboard, 1, 1, htf_status, text_color=color.white, bgcolor=htf_color, text_size=size.small)
    
    // Confluence
    conf_text = str.tostring(conf_score, "#") + "%"
    conf_color = conf_score >= 70 ? color.new(color.green, 70) : conf_score >= 50 ? color.new(color.orange, 70) : color.new(color.red, 70)
    table.cell(dashboard, 0, 2, "Confluence", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(dashboard, 1, 2, conf_text, text_color=color.white, bgcolor=conf_color, text_size=size.small)
    
    // Direction
    dir_text = stable_dir == "long" ? "LONG" : stable_dir == "short" ? "SHORT" : "NEUTRAL"
    dir_color = stable_dir == "long" ? color.new(color.green, 70) : stable_dir == "short" ? color.new(color.red, 70) : color.new(color.gray, 70)
    table.cell(dashboard, 0, 3, "Direction", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(dashboard, 1, 3, dir_text, text_color=color.white, bgcolor=dir_color, text_size=size.small)
    
    // Trend (BOS)
    trend_text = current_trend == "bullish" ? "BULLISH" : current_trend == "bearish" ? "BEARISH" : "NEUTRAL"
    trend_color = current_trend == "bullish" ? color.new(color.green, 70) : current_trend == "bearish" ? color.new(color.red, 70) : color.new(color.gray, 70)
    table.cell(dashboard, 0, 4, "BOS Trend", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(dashboard, 1, 4, trend_text, text_color=color.white, bgcolor=trend_color, text_size=size.small)
    
    // Hold bars (uthållighet)
    hold_text = str.tostring(hold) + "/" + str.tostring(required_hold)
    hold_color = hold >= required_hold ? color.new(color.green, 70) : color.new(color.orange, 70)
    table.cell(dashboard, 0, 5, "Hold Bars", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(dashboard, 1, 5, hold_text, text_color=color.white, bgcolor=hold_color, text_size=size.small)
    
    // Active zones
    zones_text = str.tostring(array.size(OBs)) + " OB | " + str.tostring(array.size(FVGs)) + " FVG"
    table.cell(dashboard, 0, 6, "Active Zones", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(dashboard, 1, 6, zones_text, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    
    // ATR
    atr_text = str.tostring(atr, format.mintick)
    table.cell(dashboard, 0, 7, "ATR(14)", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(dashboard, 1, 7, atr_text, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

// ========== RESET OBJECTS ==========
f_delete_all_objects() =>
    if array.size(OBs) > 0
        for i = array.size(OBs) - 1 to 0
            ob = array.get(OBs, i)
            box.delete(ob.box_id)
            line.delete(ob.mid_line)
        array.clear(OBs)

    if array.size(FVGs) > 0
        for i = array.size(FVGs) - 1 to 0
            fvg = array.get(FVGs, i)
            box.delete(fvg.box_id)
            line.delete(fvg.mid_line)
        array.clear(FVGs)

    if array.size(LIQs) > 0
        for i = array.size(LIQs) - 1 to 0
            liq = array.get(LIQs, i)
            line.delete(liq.line_id)
            if not na(liq.label_id)
                label.delete(liq.label_id)
        array.clear(LIQs)

    if array.size(BOSs) > 0
        for i = array.size(BOSs) - 1 to 0
            bos = array.get(BOSs, i)
            line.delete(bos.line_id)
            label.delete(bos.label_id)
        array.clear(BOSs)

    if not na(PO3.target_line)
        line.delete(PO3.target_line)
    if not na(PO3.label_id)
        label.delete(PO3.label_id)

    if not na(htf_fvg_box_last)
        box.delete(htf_fvg_box_last)
    if not na(htf_fvg_mid_line)
        line.delete(htf_fvg_mid_line)

if barstate.isfirst or needs_reset
    f_delete_all_objects()
    PO3 := Po3Phase.new("accumulation", na, na, na, na, na, na, na)
    po3_active := false
    current_trend := "neutral"
    htf_fvg_box_last := na
    htf_fvg_mid_line := na
    needs_reset := false
