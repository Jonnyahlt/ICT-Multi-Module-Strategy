//@version=6
indicator("ICT Multi-Module Strategy [v6: Optimized]", overlay=true, max_boxes_count=100, max_lines_count=100)

// ============================================================================
// GLOBAL SETTINGS & HTF CONFIGURATION
// ============================================================================
i_show_ob = input.bool(true, "Show Order Blocks", group="Modules")
i_show_fvg = input.bool(true, "Show Fair Value Gaps", group="Modules")
i_show_bos = input.bool(true, "Show Break of Structure", group="Modules")
i_show_liquidity = input.bool(true, "Show Liquidity Pools", group="Modules")
i_show_po3 = input.bool(true, "Show Po3 Phases", group="Modules")
i_show_confluence = input.bool(true, "Show Confluence", group="Modules")

i_htf1 = input.timeframe("60", "HTF 1", group="HTF")
i_htf2 = input.timeframe("240", "HTF 2", group="HTF")
i_htf3 = input.timeframe("D", "HTF 3", group="HTF")
i_use_htf = input.bool(true, "Enable HTF", group="HTF")

i_ob_ext = input.int(20, "OB Extension", minval=1, maxval=100, group="Extensions")
i_fvg_ext = input.int(30, "FVG Extension", minval=1, maxval=100, group="Extensions")
i_bos_ext = input.int(15, "BOS Extension", minval=1, maxval=100, group="Extensions")
i_liq_ext = input.int(25, "Liquidity Extension", minval=1, maxval=100, group="Extensions")
i_po3_ext = input.int(30, "Po3 Extension", minval=1, maxval=100, group="Extensions")

i_max_ob = input.int(5, "Max OB", minval=1, maxval=20, group="Limits")
i_max_fvg = input.int(3, "Max FVG", minval=1, maxval=20, group="Limits")
i_max_liq = input.int(5, "Max Liquidity", minval=1, maxval=20, group="Limits")

i_ob_inv = input.string("close_beyond", "OB Invalid", options=["close_beyond", "full_break", "midpoint"], group="Invalidation")
i_fvg_inv = input.string("full_fill", "FVG Invalid", options=["full_fill", "close_inside", "midpoint"], group="Invalidation")
i_max_retests = input.int(3, "Max Retests", minval=1, maxval=10, group="Invalidation")

i_alert_ob = input.bool(true, "Alert: OB", group="Alerts")
i_alert_fvg = input.bool(true, "Alert: FVG", group="Alerts")
i_alert_liq_ltf = input.bool(true, "Alert: LTF Sweep", group="Alerts")
i_alert_liq_htf = input.bool(true, "Alert: HTF Sweep", group="Alerts")
i_alert_conf = input.bool(true, "Alert: Confluence", group="Alerts")
i_sweep_win = input.int(3, "Sweep Window", minval=1, maxval=10, group="Alerts")

// ============================================================================
// MODULE 1: ORDER BLOCK DETECTOR
// ============================================================================
i_ob_look = input.int(10, "Lookback", minval=3, group="OB")
i_ob_wick = input.float(0.3, "Max Wick", minval=0.0, maxval=1.0, group="OB")
i_ob_body = input.float(0.3, "Min Body ATR", minval=0.1, group="OB")
i_ob_vol = input.float(1.2, "Vol vs SMA", minval=0.5, group="OB")
i_ob_bos = input.bool(true, "Require BOS", group="OB")

type OrderBlock
    int id, int start_idx, int end_idx, float top, float bottom
    bool is_bullish, bool alerted, bool invalidated
    float strength, int retest_count, box box_id

var array<OrderBlock> obs = array.new<OrderBlock>()
var int ob_id = 0

f_ob_strength(float body, float wick_r, float vol_r, bool has_bos) => 
    s = 0.0
    s += body > ta.atr(14) * i_ob_body ? 0.25 : 0.0
    s += wick_r < i_ob_wick ? 0.25 : 0.0
    s += vol_r > i_ob_vol ? 0.25 : 0.0
    s += has_bos ? 0.25 : 0.0
    s

f_detect_ob_bull() =>
    is_ob = false, ob_t = 0.0, ob_b = 0.0, str = 0.0
    vol_sma = ta.sma(volume, 20)
    if close > open and close > open[1] and open < close[1] and close[1] < open[1]
        body = open[1] - close[1], wick = close[1] - low[1]
        wick_r = body > 0 ? wick / body : 0.0, vol_r = vol_sma > 0 ? volume[1] / vol_sma : 1.0
        if wick_r <= i_ob_wick and body > ta.atr(14) * i_ob_body
            is_ob := true, ob_t := open[1], ob_b := close[1]
            str := f_ob_strength(body, wick_r, vol_r, false)
    [is_ob, ob_t, ob_b, str]

f_detect_ob_bear() =>
    is_ob = false, ob_t = 0.0, ob_b = 0.0, str = 0.0
    vol_sma = ta.sma(volume, 20)
    if close < open and close < open[1] and open > close[1] and close[1] > open[1]
        body = close[1] - open[1], wick = high[1] - close[1]
        wick_r = body > 0 ? wick / body : 0.0, vol_r = vol_sma > 0 ? volume[1] / vol_sma : 1.0
        if wick_r <= i_ob_wick and body > ta.atr(14) * i_ob_body
            is_ob := true, ob_t := close[1], ob_b := open[1]
            str := f_ob_strength(body, wick_r, vol_r, false)
    [is_ob, ob_t, ob_b, str]

if i_show_ob
    [is_b, t_b, b_b, s_b] = f_detect_ob_bull()
    if is_b
        if array.size(obs) >= i_max_ob
            old = array.shift(obs)
            box.delete(old.box_id)
        col = s_b > 0.75 ? color.new(color.green, 70) : s_b > 0.5 ? color.new(color.green, 80) : color.new(color.green, 90)
        bx = box.new(bar_index - 1, t_b, bar_index + i_ob_ext, b_b, border_color=color.green, bgcolor=col)
        array.push(obs, OrderBlock.new(ob_id, bar_index - 1, bar_index + i_ob_ext, t_b, b_b, true, false, false, s_b, 0, bx))
        ob_id += 1
    
    [is_br, t_br, b_br, s_br] = f_detect_ob_bear()
    if is_br
        if array.size(obs) >= i_max_ob
            old = array.shift(obs)
            box.delete(old.box_id)
        col = s_br > 0.75 ? color.new(color.red, 70) : s_br > 0.5 ? color.new(color.red, 80) : color.new(color.red, 90)
        bx = box.new(bar_index - 1, t_br, bar_index + i_ob_ext, b_br, border_color=color.red, bgcolor=col)
        array.push(obs, OrderBlock.new(ob_id, bar_index - 1, bar_index + i_ob_ext, t_br, b_br, false, false, false, s_br, 0, bx))
        ob_id += 1
    
    if array.size(obs) > 0
        for i = array.size(obs) - 1 to 0
            ob = array.get(obs, i)
            if not ob.invalidated
                is_touch = low <= ob.top and high >= ob.bottom
                if is_touch and not ob.alerted and i_alert_ob
                    alert("OB " + (ob.is_bullish ? "Bull" : "Bear") + " touched", alert.freq_once_per_bar)
                    ob.alerted := true, array.set(obs, i, ob)
                
                is_inv = false
                if i_ob_inv == "close_beyond"
                    is_inv := ob.is_bullish ? close < ob.bottom : close > ob.top
                else if i_ob_inv == "full_break"
                    is_inv := ob.is_bullish ? low < ob.bottom : high > ob.top
                else if i_ob_inv == "midpoint"
                    mid = (ob.top + ob.bottom) / 2
                    is_inv := ob.is_bullish ? close < mid : close > mid
                
                if is_touch
                    ob.retest_count += 1
                if ob.retest_count >= i_max_retests
                    is_inv := true
                
                if is_inv
                    box.delete(ob.box_id), ob.invalidated := true, array.set(obs, i, ob)

// ============================================================================
// MODULE 2: FAIR VALUE GAP (ICT Correct)
// ============================================================================
i_fvg_min = input.float(0.0, "Min Gap ATR", minval=0.0, group="FVG")
i_fvg_wick = input.bool(true, "Use Wicks", group="FVG")

type FVG
    int id, int start_idx, int end_idx, float top, float bottom
    bool is_bullish, bool alerted, bool invalidated, bool tested
    box box_id

var array<FVG> fvgs = array.new<FVG>()
var int fvg_id = 0

f_fvg_bull() =>
    is_fvg = false, t = 0.0, b = 0.0
    atr = ta.atr(14)
    b_val = i_fvg_wick ? high[2] : math.max(open[2], close[2])
    t_val = i_fvg_wick ? low[0] : math.min(open[0], close[0])
    if t_val > b_val and (t_val - b_val) >= atr * i_fvg_min
        is_fvg := true, t := t_val, b := b_val
    [is_fvg, t, b]

f_fvg_bear() =>
    is_fvg = false, t = 0.0, b = 0.0
    atr = ta.atr(14)
    t_val = i_fvg_wick ? low[2] : math.min(open[2], close[2])
    b_val = i_fvg_wick ? high[0] : math.max(open[0], close[0])
    if t_val > b_val and (t_val - b_val) >= atr * i_fvg_min
        is_fvg := true, t := t_val, b := b_val
    [is_fvg, t, b]

if i_show_fvg
    [is_fb, t_fb, b_fb] = f_fvg_bull()
    if is_fb
        if array.size(fvgs) >= i_max_fvg
            old = array.shift(fvgs)
            box.delete(old.box_id)
        bx = box.new(bar_index - 2, t_fb, bar_index + i_fvg_ext, b_fb, border_color=color.green, bgcolor=color.new(color.green, 85), border_style=line.style_dashed)
        array.push(fvgs, FVG.new(fvg_id, bar_index - 2, bar_index + i_fvg_ext, t_fb, b_fb, true, false, false, false, bx))
        fvg_id += 1
    
    [is_fbr, t_fbr, b_fbr] = f_fvg_bear()
    if is_fbr
        if array.size(fvgs) >= i_max_fvg
            old = array.shift(fvgs)
            box.delete(old.box_id)
        bx = box.new(bar_index - 2, t_fbr, bar_index + i_fvg_ext, b_fbr, border_color=color.red, bgcolor=color.new(color.red, 85), border_style=line.style_dashed)
        array.push(fvgs, FVG.new(fvg_id, bar_index - 2, bar_index + i_fvg_ext, t_fbr, b_fbr, false, false, false, false, bx))
        fvg_id += 1
    
    if array.size(fvgs) > 0
        for i = array.size(fvgs) - 1 to 0
            fvg = array.get(fvgs, i)
            if not fvg.invalidated
                is_test = low <= fvg.top and high >= fvg.bottom
                if is_test and not fvg.tested and i_alert_fvg
                    alert("FVG " + (fvg.is_bullish ? "Bull" : "Bear") + " first test", alert.freq_once_per_bar)
                    fvg.tested := true, array.set(fvgs, i, fvg)
                
                is_inv = false
                if i_fvg_inv == "full_fill"
                    is_inv := fvg.is_bullish ? close < fvg.bottom : close > fvg.top
                else if i_fvg_inv == "close_inside"
                    is_inv := close >= fvg.bottom and close <= fvg.top
                else if i_fvg_inv == "midpoint"
                    mid = (fvg.top + fvg.bottom) / 2
                    is_inv := fvg.is_bullish ? close < mid : close > mid
                
                if is_inv
                    box.delete(fvg.box_id), fvg.invalidated := true, array.set(fvgs, i, fvg)

// ============================================================================
// MODULE 3: BOS + MSS
// ============================================================================
i_bos_look = input.int(10, "Swing Lookback", minval=5, group="BOS")
i_bos_move = input.float(0.5, "Min Move %", minval=0.1, group="BOS")
i_bos_vol = input.bool(true, "Volume Filter", group="BOS")
i_bos_vol_th = input.float(1.2, "Vol Threshold", minval=1.0, group="BOS")

var string trend = "neutral"
var array<line> bos_lines = array.new<line>()
var array<label> bos_labels = array.new<label>()

f_swing_high(int look) =>
    h = high[look], is_s = true
    for j = 0 to look - 1
        if high[j] > h
            is_s := false
            break
    if is_s
        for j = look + 1 to look * 2
            if high[j] > h
                is_s := false
                break
    is_s ? h : na

f_swing_low(int look) =>
    l = low[look], is_s = true
    for j = 0 to look - 1
        if low[j] < l
            is_s := false
            break
    if is_s
        for j = look + 1 to look * 2
            if low[j] < l
                is_s := false
                break
    is_s ? l : na

if i_show_bos
    sh = f_swing_high(i_bos_look), sl = f_swing_low(i_bos_look)
    vol_sma = ta.sma(volume, 20)
    
    if not na(sh) and close > sh
        move_pct = ((close - sh) / sh) * 100
        vol_ok = not i_bos_vol or volume > vol_sma * i_bos_vol_th
        if move_pct >= i_bos_move and vol_ok
            ln = line.new(bar_index - i_bos_look, sh, bar_index + i_bos_ext, sh, color=color.green, width=2)
            lb = label.new(bar_index, sh, "BOS↑", color=color.green, textcolor=color.white, style=label.style_label_up, size=size.tiny)
            array.push(bos_lines, ln), array.push(bos_labels, lb)
            trend := "bullish"
    
    if not na(sl) and close < sl
        move_pct = ((sl - close) / sl) * 100
        vol_ok = not i_bos_vol or volume > vol_sma * i_bos_vol_th
        if move_pct >= i_bos_move and vol_ok
            ln = line.new(bar_index - i_bos_look, sl, bar_index + i_bos_ext, sl, color=color.red, width=2)
            lb = label.new(bar_index, sl, "BOS↓", color=color.red, textcolor=color.white, style=label.style_label_down, size=size.tiny)
            array.push(bos_lines, ln), array.push(bos_labels, lb)
            trend := "bearish"

// ============================================================================
// MODULE 4: LIQUIDITY POOL + HTF SWEEPS
// ============================================================================
i_liq_look = input.int(20, "Liquidity Lookback", minval=5, group="Liquidity")
i_liq_min = input.float(0.3, "Min Swing ATR", minval=0.1, group="Liquidity")

type Liquidity
    int id, float level, bool is_high, bool swept, int sweep_bar
    line line_id

var array<Liquidity> liqs = array.new<Liquidity>()
var int liq_id = 0

f_liq_high() =>
    ph = ta.pivothigh(high, i_liq_look, i_liq_look), is_sig = false
    atr = ta.atr(14)
    if not na(ph)
        swing_sz = ph - ta.lowest(low, i_liq_look * 2)
        if swing_sz >= atr * i_liq_min
            is_sig := true
    [is_sig, ph]

f_liq_low() =>
    pl = ta.pivotlow(low, i_liq_look, i_liq_look), is_sig = false
    atr = ta.atr(14)
    if not na(pl)
        swing_sz = ta.highest(high, i_liq_look * 2) - pl
        if swing_sz >= atr * i_liq_min
            is_sig := true
    [is_sig, pl]

if i_show_liquidity
    [is_h, lh] = f_liq_high()
    if is_h
        if array.size(liqs) >= i_max_liq
            old = array.shift(liqs)
            line.delete(old.line_id)
        ln = line.new(bar_index - i_liq_look, lh, bar_index + i_liq_ext, lh, color=color.yellow, width=1, style=line.style_dotted)
        label.new(bar_index - i_liq_look, lh, "LIQ", color=color.yellow, textcolor=color.black, style=label.style_label_down, size=size.tiny)
        array.push(liqs, Liquidity.new(liq_id, lh, true, false, 0, ln))
        liq_id += 1
    
    [is_l, ll] = f_liq_low()
    if is_l
        if array.size(liqs) >= i_max_liq
            old = array.shift(liqs)
            line.delete(old.line_id)
        ln = line.new(bar_index - i_liq_look, ll, bar_index + i_liq_ext, ll, color=color.yellow, width=1, style=line.style_dotted)
        label.new(bar_index - i_liq_look, ll, "LIQ", color=color.yellow, textcolor=color.black, style=label.style_label_up, size=size.tiny)
        array.push(liqs, Liquidity.new(liq_id, ll, false, false, 0, ln))
        liq_id += 1
    
    if array.size(liqs) > 0
        for i = array.size(liqs) - 1 to 0
            liq = array.get(liqs, i)
            if not liq.swept
                is_sweep = liq.is_high ? high > liq.level and close < liq.level : low < liq.level and close > liq.level
                if is_sweep and (bar_index - liq.sweep_bar) <= i_sweep_win
                    if i_alert_liq_ltf
                        alert("LTF Sweep " + (liq.is_high ? "High" : "Low") + " @ " + str.tostring(liq.level), alert.freq_once_per_bar)
                    line.delete(liq.line_id), liq.swept := true, array.set(liqs, i, liq)

// ============================================================================
// MODULE 5: PO3 / FRACTAL MOMENTUM
// ============================================================================
i_po3_depth = input.int(5, "Fractal Depth", minval=3, group="Po3")
i_po3_manip = input.float(0.3, "Manip Threshold ATR", minval=0.1, group="Po3")
i_po3_mult = input.float(1.5, "Expansion Mult", minval=1.0, group="Po3")

type Po3
    string phase, float acc_h, float acc_l, float manip_lvl, float target
    int start_bar, line target_line

var Po3 po3 = Po3.new("accumulation", 0.0, 0.0, 0.0, 0.0, 0, na)
var bool po3_active = false

f_acc() =>
    rh = ta.highest(high, i_po3_depth * 2), rl = ta.lowest(low, i_po3_depth * 2)
    rng = rh - rl, atr = ta.atr(14)
    is_acc = rng < atr * 0.5
    [is_acc, rh, rl]

f_manip(float ah, float al) =>
    is_m = false, m_lvl = 0.0, is_bull = false, atr = ta.atr(14)
    if low < al - (atr * i_po3_manip)
        is_m := true, m_lvl := low, is_bull := true
    if high > ah + (atr * i_po3_manip)
        is_m := true, m_lvl := high, is_bull := false
    [is_m, m_lvl, is_bull]

if i_show_po3
    [is_a, ah, al] = f_acc()
    if is_a and po3.phase == "accumulation"
        po3.acc_h := ah, po3.acc_l := al, po3.start_bar := bar_index
    
    [is_m, m_l, is_b] = f_manip(po3.acc_h, po3.acc_l)
    if is_m and po3.phase == "accumulation"
        po3.phase := "manipulation", po3.manip_lvl := m_l
        rng = po3.acc_h - po3.acc_l
        if is_b
            po3.target := po3.acc_h + (rng * i_po3_mult)
            label.new(bar_index, low, "Po3↓→↑", color=color.blue, textcolor=color.white, style=label.style_label_up, size=size.small)
        else
            po3.target := po3.acc_l - (rng * i_po3_mult)
            label.new(bar_index, high, "Po3↑→↓", color=color.blue, textcolor=color.white, style=label.style_label_down, size=size.small)
        po3.target_line := line.new(bar_index, po3.target, bar_index + i_po3_ext, po3.target, color=color.blue, width=2, style=line.style_dashed)
        po3_active := true

// ============================================================================
// MODULE 6: CONFLUENCE ENGINE
// ============================================================================
i_conf_th = input.int(70, "Threshold", minval=0, maxval=100, group="Confluence")
i_w_ob = input.float(25.0, "OB Weight", minval=0, maxval=100, group="Confluence")
i_w_fvg = input.float(20.0, "FVG Weight", minval=0, maxval=100, group="Confluence")
i_w_bos = input.float(15.0, "BOS Weight", minval=0, maxval=100, group="Confluence")
i_w_liq = input.float(30.0, "Liq Weight", minval=0, maxval=100, group="Confluence")
i_w_po3 = input.float(10.0, "Po3 Weight", minval=0, maxval=100, group="Confluence")

f_confluence() =>
    bull = 0.0, bear = 0.0
    
    ob_b = 0.0, ob_br = 0.0
    if array.size(obs) > 0
        for i = 0 to array.size(obs) - 1
            ob = array.get(obs, i)
            if not ob.invalidated and close >= ob.bottom and close <= ob.top
                if ob.is_bullish
                    ob_b := math.max(ob_b, ob.strength)
                else
                    ob_br := math.max(ob_br, ob.strength)
    bull += ob_b * i_w_ob, bear += ob_br * i_w_ob
    
    fvg_b = 0.0, fvg_br = 0.0
    if array.size(fvgs) > 0
        for i = 0 to array.size(fvgs) - 1
            fvg = array.get(fvgs, i)
            if not fvg.invalidated and close >= fvg.bottom and close <= fvg.top
                if fvg.is_bullish
                    fvg_b := 1.0
                else
                    fvg_br := 1.0
    bull += fvg_b * i_w_fvg, bear += fvg_br * i_w_fvg
    
    if trend == "bullish"
        bull += i_w_bos
    else if trend == "bearish"
        bear += i_w_bos
    
    liq_b = 0.0, liq_br = 0.0
    if array.size(liqs) > 0
        for i = 0 to array.size(liqs) - 1
            liq = array.get(liqs, i)
            if not liq.swept
                dist = math.abs(close - liq.level)
                if dist < ta.atr(14) * 0.5
                    if liq.is_high
                        liq_br := 1.0
                    else
                        liq_b := 1.0
    bull += liq_b * i_w_liq, bear += liq_br * i_w_liq
    
    if po3_active
        sig = po3.target > close ? 1.0 : -1.0
        if sig > 0
            bull += i_w_po3
        else
            bear += i_w_po3
    
    net = bull - bear
    conf = math.max(bull, bear)
    dir = net > 0 ? "LONG" : net < 0 ? "SHORT" : "NEUTRAL"
    [conf, dir]

var label conf_lbl = na
if i_show_confluence
    [conf, dir] = f_confluence()
    if not na(conf_lbl)
        label.delete(conf_lbl)
    if conf >= i_conf_th
        col = dir == "LONG" ? color.green : dir == "SHORT" ? color.red : color.gray
        txt = dir + " " + str.tostring(conf, "#") + "%"
        conf_lbl := label.new(bar_index, high + ta.atr(14) * 0.5, txt, color=col, textcolor=color.white, style=label.style_label_down, size=size.normal)
        if i_alert_conf and (dir == "LONG" or dir == "SHORT")
            alert("Confluence: " + dir + " " + str.tostring(conf, "#") + "%", alert.freq_once_per_bar)

// ============================================================================
// MODULE 7: RISK MANAGER (Placeholder for Strategy Version)
// ============================================================================
i_risk_rr = input.float(2.0, "Risk:Reward", minval=0.5, group="Risk")
i_risk_atr_stop = input.float(1.5, "ATR Stop", minval=0.5, group="Risk")
i_risk_pct = input.float(1.0, "Risk %", minval=0.1, maxval=10.0, group="Risk")

// ============================================================================
// END OF SCRIPT
// ============================================================================
